import * as fs from "fs";
import * as chalk from "chalk";
import * as path from "path";
import * as childProcess from "child_process";
import { coerce, compare, valid } from "semver";
import { downloadBlob, extractIPA, fileDoesNotExistOrIsDirectory } from "./utils/file-utils";
import * as dotenv from "dotenv";
import { DotenvParseOutput } from "dotenv";
import * as cli from "../script/types/cli";
import { log, sdk } from "./command-executor";

const g2js = require("gradle-to-js/lib/parser");

export function isValidVersion(version: string): boolean {
  return !!valid(version) || /^\d+\.\d+$/.test(version);
}

export async function getBundleSourceMapOutput(command: cli.IReleaseReactCommand, bundleName: string, sourcemapOutputFolder: string) {
  let bundleSourceMapOutput: string | undefined;
  switch (command.platform) {
    case "android": {
      // see BundleHermesCTask -> resolvePackagerSourceMapFile
      // for Hermes targeted bundles there are 2 source maps: "packager" (metro) and "compiler" (Hermes)
      // Metro bundles use <bundleAssetName>.packager.map notation
      const isHermes = await isHermesEnabled(command, command.platform);
      if (isHermes) {
        bundleSourceMapOutput = path.join(sourcemapOutputFolder, bundleName + ".packager.map");
      } else {
        bundleSourceMapOutput = path.join(sourcemapOutputFolder, bundleName + ".map");
      }

      break;
    }
    case "ios": {
      // see react-native-xcode.sh
      // to match js bundle generated by Xcode and by Revopush cli we must respect SOURCEMAP_FILE value
      // because it appears as //# sourceMappingURL value in a js bundle
      const xcodeDotEnvValue = getXcodeDotEnvValue("SOURCEMAP_FILE");
      const sourceMapFilename = xcodeDotEnvValue ? path.basename(xcodeDotEnvValue) : bundleName + ".map";

      bundleSourceMapOutput = path.join(sourcemapOutputFolder, sourceMapFilename);

      break;
    }
    default:
      throw new Error('Platform must be either "android", "ios" or "windows".');
  }
  return bundleSourceMapOutput;
}

export async function takeHermesBaseBytecode(
  command: cli.IReleaseReactCommand,
  baseReleaseTmpFolder: string,
  outputFolder: string,
  bundleName: string
): Promise<string | null> {
  const { bundleBlobUrl } = await sdk.getBaseRelease(command.appName, command.deploymentName, command.appStoreVersion);
  if (!bundleBlobUrl) {
    return null;
  }

  const baseReleaseArchive = await downloadBlob(bundleBlobUrl, baseReleaseTmpFolder);
  await extractIPA(baseReleaseArchive, baseReleaseTmpFolder);
  const baseReleaseBundle = path.join(baseReleaseTmpFolder, path.basename(outputFolder), bundleName);

  if (!fs.existsSync(baseReleaseBundle)) {
    log(chalk.cyan("\nNo base release available...\n"));
    return null;
  }

  return baseReleaseBundle;
}

export async function runHermesEmitBinaryCommand(
  command: cli.IReleaseReactCommand,
  bundleName: string,
  outputFolder: string,
  sourcemapOutputFolder: string,
  extraHermesFlags: string[],
  gradleFile: string,
  baseBytecode?: string
): Promise<void> {
  const hermesArgs: string[] = [];
  const envNodeArgs: string = process.env.CODE_PUSH_NODE_ARGS;

  if (typeof envNodeArgs !== "undefined") {
    Array.prototype.push.apply(hermesArgs, envNodeArgs.trim().split(/\s+/));
  }

  Array.prototype.push.apply(hermesArgs, [
    "-emit-binary",
    "-O",
    "-out",
    path.join(outputFolder, bundleName + ".hbc"),
    path.join(outputFolder, bundleName),
    "-w",
    "-max-diagnostic-width=80",
    ...extraHermesFlags,
  ]);

  if (sourcemapOutputFolder) {
    hermesArgs.push("-output-source-map");
  }

  if (baseBytecode) {
    hermesArgs.push("-base-bytecode", baseBytecode);
  }

  console.log(chalk.cyan("Converting JS bundle to byte code via Hermes, running command:\n"));
  const hermesCommand = await getHermesCommand(gradleFile);
  const hermesProcess = childProcess.spawn(hermesCommand, hermesArgs);
  console.log(`${hermesCommand} ${hermesArgs.join(" ")}`);

  return new Promise<void>((resolve, reject) => {
    hermesProcess.stdout.on("data", (data: Buffer) => {
      console.log(data.toString().trim());
    });

    hermesProcess.stderr.on("data", (data: Buffer) => {
      console.error(data.toString().trim());
    });

    hermesProcess.on("close", (exitCode: number, signal: string) => {
      if (exitCode !== 0) {
        reject(new Error(`"hermes" command failed (exitCode=${exitCode}, signal=${signal}).`));
      }
      // Copy HBC bundle to overwrite JS bundle
      const source = path.join(outputFolder, bundleName + ".hbc");
      const destination = path.join(outputFolder, bundleName);
      fs.copyFile(source, destination, (err) => {
        if (err) {
          console.error(err);
          reject(new Error(`Copying file ${source} to ${destination} failed. "hermes" previously exited with code ${exitCode}.`));
        }
        fs.unlink(source, (err) => {
          if (err) {
            console.error(err);
            reject(err);
          }
          resolve(null as void);
        });
      });
    });
  }).then(async () => {
    if (!sourcemapOutputFolder) {
      // skip source map compose if source map is not enabled
      return;
    }

    const composeSourceMapsPath = getComposeSourceMapsPath();
    if (!composeSourceMapsPath) {
      throw new Error("react-native compose-source-maps.js scripts is not found");
    }

    const jsCompilerSourceMapFile = path.join(outputFolder, bundleName + ".hbc" + ".map");
    if (!fs.existsSync(jsCompilerSourceMapFile)) {
      throw new Error(`sourcemap file ${jsCompilerSourceMapFile} is not found`);
    }

    const platformSourceMapOutput = await getBundleSourceMapOutput(command, bundleName, sourcemapOutputFolder);
    return new Promise((resolve, reject) => {
      let bundleSourceMapOutput = sourcemapOutputFolder;
      let combinedSourceMapOutput = sourcemapOutputFolder;

      if (!sourcemapOutputFolder.endsWith(".map")) {
        bundleSourceMapOutput = platformSourceMapOutput;
        switch (command.platform) {
          case "android": {
            combinedSourceMapOutput = path.join(sourcemapOutputFolder, bundleName + ".map");
            break;
          }
          case "ios": {
            combinedSourceMapOutput = bundleSourceMapOutput;
            break;
          }
          default:
            throw new Error('Platform must be either "android", "ios" or "windows".');
        }
      }
      const composeSourceMapsArgs = [
        composeSourceMapsPath,
        bundleSourceMapOutput,
        jsCompilerSourceMapFile,
        "-o",
        combinedSourceMapOutput,
      ];

      // https://github.com/facebook/react-native/blob/master/react.gradle#L211
      // https://github.com/facebook/react-native/blob/master/scripts/react-native-xcode.sh#L178
      // packager.sourcemap.map + hbc.sourcemap.map = sourcemap.map
      const composeSourceMapsProcess = childProcess.spawn("node", composeSourceMapsArgs);
      console.log(`${composeSourceMapsPath} ${composeSourceMapsArgs.join(" ")}`);

      composeSourceMapsProcess.stdout.on("data", (data: Buffer) => {
        console.log(data.toString().trim());
      });

      composeSourceMapsProcess.stderr.on("data", (data: Buffer) => {
        console.error(data.toString().trim());
      });

      composeSourceMapsProcess.on("close", (exitCode: number, signal: string) => {
        if (exitCode !== 0) {
          reject(new Error(`"compose-source-maps" command failed (exitCode=${exitCode}, signal=${signal}).`));
        }

        // Delete the HBC sourceMap, otherwise it will be included in 'code-push' bundle as well
        fs.unlink(jsCompilerSourceMapFile, (err) => {
          if (err) {
            console.error(err);
            reject(err);
          }

          resolve(null);
        });
      });
    });
  });
}

export function getXcodeDotEnvValue(key: string): string | undefined {
  const xcodeEnvs = loadEnvAsMap([path.join("ios", ".xcode.env.local"), path.join("ios", ".xcode.env.local")]);
  return xcodeEnvs.get(key);
}

export async function getMinifyParams(command: cli.IReleaseReactCommand) {
  const isHermes = await isHermesEnabled(command);

  switch (command.platform) {
    case "android": {
      // android always explicitly pass --minify true/false
      // TaskConfiguration        it.minifyEnabled.set(!isHermesEnabledInThisVariant)
      return ["--minify", !isHermes];
    }
    case "ios": {
      //if [[ $USE_HERMES != false && $DEV == false ]]; then
      //   EXTRA_ARGS+=("--minify" "false")
      // fi
      // ios does pass --minify false only if Hermes enables and does pass anything otherwise
      return isHermes ? ["--minify", false] : [];
    }
    default:
      throw new Error('Platform must be either "android", "ios" or "windows".');
  }
}

export async function isHermesEnabled(command: cli.IReleaseReactCommand, platform: string = command.platform.toLowerCase()) {
  // Check if we have to run hermes to compile JS to Byte Code if Hermes is enabled in Podfile and we're releasing an iOS build
  const isAndroidHermesEnabled = await getAndroidHermesEnabled(command.gradleFile);
  const isIOSHermesEnabled = getiOSHermesEnabled(command.podFile);

  return command.useHermes || (platform === "android" && isAndroidHermesEnabled) || (platform === "ios" && isIOSHermesEnabled);
}

function parseBuildGradleFile(gradleFile: string) {
  let buildGradlePath: string = path.join("android", "app");
  if (gradleFile) {
    buildGradlePath = gradleFile;
  }
  if (fs.lstatSync(buildGradlePath).isDirectory()) {
    buildGradlePath = path.join(buildGradlePath, "build.gradle");
  }

  if (fileDoesNotExistOrIsDirectory(buildGradlePath)) {
    throw new Error(`Unable to find gradle file "${buildGradlePath}".`);
  }

  return g2js.parseFile(buildGradlePath).catch(() => {
    throw new Error(`Unable to parse the "${buildGradlePath}" file. Please ensure it is a well-formed Gradle file.`);
  });
}

function parseGradlePropertiesFile(gradleFile: string): Record<string, string> {
  let gradlePropsPath: string = path.join("android", "gradle.properties");

  try {
    if (gradleFile) {
      const base = gradleFile;
      const stat = fs.lstatSync(base);

      if (stat.isDirectory()) {
        if (path.basename(base) === "app") {
          gradlePropsPath = path.join(base, "..", "gradle.properties");
        } else {
          gradlePropsPath = path.join(base, "gradle.properties");
        }
      } else {
        gradlePropsPath = path.join(path.dirname(base), "..", "gradle.properties");
      }
    }
  } catch {}

  gradlePropsPath = path.normalize(gradlePropsPath);

  if (fileDoesNotExistOrIsDirectory(gradlePropsPath)) {
    throw new Error(`Unable to find gradle.properties file "${gradlePropsPath}".`);
  }

  const text = fs.readFileSync(gradlePropsPath, "utf8");
  const props: Record<string, string> = {};
  for (const rawLine of text.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith("#")) continue;
    const m = line.match(/^([^=\s]+)\s*=\s*(.*)$/);
    if (m) {
      const key = m[1].trim();
      const val = m[2].trim();
      props[key] = val;
    }
  }
  return props;
}

async function getHermesCommandFromGradle(gradleFile: string): Promise<string> {
  const buildGradle: any = await parseBuildGradleFile(gradleFile);
  const hermesCommandProperty: any = Array.from(buildGradle["project.ext.react"] || []).find((prop: string) =>
    prop.trim().startsWith("hermesCommand:")
  );
  if (hermesCommandProperty) {
    return hermesCommandProperty.replace("hermesCommand:", "").trim().slice(1, -1);
  } else {
    return "";
  }
}

async function getAndroidHermesEnabled(gradleFile: string): Promise<boolean> {
  try {
    const props = parseGradlePropertiesFile(gradleFile);
    if (typeof props.hermesEnabled !== "undefined") {
      const v = String(props.hermesEnabled).trim().toLowerCase();
      if (v === "true") return true;
      if (v === "false") return false;
    }
  } catch {}

  try {
    const buildGradle: any = await parseBuildGradleFile(gradleFile);
    const lines: string[] = Array.from(buildGradle["project.ext.react"] || []);
    if (lines.some((l) => /\benableHermes\s*:\s*true\b/.test(l))) return true;
    if (lines.some((l) => /\benableHermes\s*:\s*false\b/.test(l))) return false;
  } catch {}

  const rnVersion = coerce(getReactNativeVersion())?.version;
  return rnVersion && compare(rnVersion, "0.70.0") >= 0;
}

function getiOSHermesEnabled(podFile: string): boolean {
  let podPath = path.join("ios", "Podfile");
  if (podFile) {
    podPath = podFile;
  }
  if (fileDoesNotExistOrIsDirectory(podPath)) {
    throw new Error(`Unable to find Podfile file "${podPath}".`);
  }

  try {
    const podFileContents = fs.readFileSync(podPath).toString();

    const hasTrue = /([^#\n]*:?hermes_enabled(\s+|\n+)?(=>|:)(\s+|\n+)?true)/.test(podFileContents);
    if (hasTrue) return true;

    const hasFalse = /([^#\n]*:?hermes_enabled(\s+|\n+)?(=>|:)(\s+|\n+)?false)/.test(podFileContents);
    if (hasFalse) return false;

    const rnVersion = coerce(getReactNativeVersion())?.version;
    return rnVersion && compare(rnVersion, "0.70.0") >= 0;
  } catch (error) {
    throw error;
  }
}

function loadEnvAsMap(envPaths = []): Map<string, string | undefined> {
  const merged: DotenvParseOutput = {};

  for (const envPath of envPaths) {
    if (fs.existsSync(envPath)) {
      Object.assign(merged, dotenv.parse(fs.readFileSync(envPath))); // later files override earlier ones
    }
  }

  // fallback to process.env for anything missing
  return new Map([...Object.entries(process.env), ...Object.entries(merged)]);
}

function getHermesOSBin(): string {
  switch (process.platform) {
    case "win32":
      return "win64-bin";
    case "darwin":
      return "osx-bin";
    case "freebsd":
    case "linux":
    case "sunos":
    default:
      return "linux64-bin";
  }
}

function getHermesOSExe(): string {
  const react63orAbove = compare(coerce(getReactNativeVersion()).version, "0.63.0") !== -1;
  const hermesExecutableName = react63orAbove ? "hermesc" : "hermes";
  switch (process.platform) {
    case "win32":
      return hermesExecutableName + ".exe";
    default:
      return hermesExecutableName;
  }
}

async function getHermesCommand(gradleFile: string): Promise<string> {
  const fileExists = (file: string): boolean => {
    try {
      return fs.statSync(file).isFile();
    } catch (e) {
      return false;
    }
  };
  // Hermes is bundled with react-native since 0.69
  const reactNativePath = getReactNativePackagePath();
  const bundledHermesEngine = path.join(reactNativePath, "sdks", "hermesc", getHermesOSBin(), getHermesOSExe());
  if (fileExists(bundledHermesEngine)) {
    return bundledHermesEngine;
  }

  const gradleHermesCommand = await getHermesCommandFromGradle(gradleFile);
  if (gradleHermesCommand) {
    return path.join("android", "app", gradleHermesCommand.replace("%OS-BIN%", getHermesOSBin()));
  } else {
    const nodeModulesPath = getNodeModulesPath(reactNativePath);

    // assume if hermes-engine exists it should be used instead of hermesvm
    const hermesEngine = path.join(nodeModulesPath, "hermes-engine", getHermesOSBin(), getHermesOSExe());
    if (fileExists(hermesEngine)) {
      return hermesEngine;
    }
    return path.join(nodeModulesPath, "hermesvm", getHermesOSBin(), "hermes");
  }
}

function getComposeSourceMapsPath(): string {
  // detect if compose-source-maps.js script exists
  const composeSourceMaps = path.join(getReactNativePackagePath(), "scripts", "compose-source-maps.js");
  if (fs.existsSync(composeSourceMaps)) {
    return composeSourceMaps;
  }
  return null;
}

function getNodeModulesPath(reactNativePath: string): string {
  const nodeModulesPath = path.dirname(reactNativePath);
  if (directoryExistsSync(nodeModulesPath)) {
    return nodeModulesPath;
  }

  return path.join("node_modules");
}

export function getReactNativePackagePath(): string {
  const result = childProcess.spawnSync("node", ["--print", "require.resolve('react-native/package.json')"]);
  const packagePath = path.dirname(result.stdout.toString());
  if (result.status === 0 && directoryExistsSync(packagePath)) {
    return packagePath;
  }

  return path.join("node_modules", "react-native");
}

export function directoryExistsSync(dirname: string): boolean {
  try {
    return fs.statSync(dirname).isDirectory();
  } catch (err) {
    if (err.code !== "ENOENT") {
      throw err;
    }
  }
  return false;
}

export function getReactNativeVersion(): string {
  let packageJsonFilename;
  let projectPackageJson;
  try {
    packageJsonFilename = path.join(process.cwd(), "package.json");
    projectPackageJson = JSON.parse(fs.readFileSync(packageJsonFilename, "utf-8"));
  } catch (error) {
    throw new Error(
      `Unable to find or read "package.json" in the CWD. The "release-react" command must be executed in a React Native project folder.`
    );
  }

  const projectName: string = projectPackageJson.name;
  if (!projectName) {
    throw new Error(`The "package.json" file in the CWD does not have the "name" field set.`);
  }

  return (
    (projectPackageJson.dependencies && projectPackageJson.dependencies["react-native"]) ||
    (projectPackageJson.devDependencies && projectPackageJson.devDependencies["react-native"])
  );
}
